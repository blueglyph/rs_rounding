#![cfg(test)]

use crate::{f64_sround, INIT_DIGIT, Policy, RoundTestIter, str_sround};

#[test]
fn test_format() {
    let tests = vec![
        (0.0_f64, "0"),
        (f64::NAN, "NaN"),
        (f64::INFINITY, "inf"),
        (f64::NEG_INFINITY, "-inf"),
        (1.23456789E18, "1234567890000000000.00"),
        (-1.23456789E18, "-1234567890000000000.00"),
        (1.23456789E-18, "0.00"),
        (-1.23456789E-18, "-0.00"),
        (1.25, "1.25"),
        (1.125, "1.13"),
        (1.135, "1.14"),
        (29.999999999998765, "30.00"),
        (29.999949999998765, "30.00"),
        (29.949999999998765, "29.95"),
        (29.994999, "29.99"),
        (99.999999999998765, "100.00"),
        (9.999999999998765, "10.00"),
        (0.999999999998765, "1.00"),
        (-1.25, "-1.25"),
        (-1.125, "-1.13"),
        (-1.135, "-1.14"),
        (-29.999999999998765, "-30.00"),
        (-29.999949999998765, "-30.00"),
        (-29.949999999998765, "-29.95"),
        (-29.994999, "-29.99"),
        (-99.999999999998765, "-100.00"),
        (-9.999999999998765, "-10.00"),
        (-0.999999999998765, "-1.00"),
    ];
    for (val, expected) in tests {
        let actual = f64_sround(val, 2, &Policy::AwayFromZero);
        assert_eq!(actual, expected, "original value: {}", val);
    }
}

#[test]
fn test_precision() {
    let f = "1.49495";
    let exp_list = ["1", "1.5", "1.49", "1.495", "1.4950", "1.49495"];
    for (pr, expected) in exp_list.into_iter().enumerate() {
        let actual = str_sround(f, pr, &Policy::AwayFromZero);
        assert_eq!(actual, expected, "mismatch with precision = {pr}");
    }
}

#[test]
fn visual_test() {
    // not a real test, just a visual comparison

    for policy in &[Policy::AwayFromZero, Policy::ToEven] {
        println!("{:?} ===================================================", policy);
        println!("'original value': 'Display-rounded' <> 'f64_sround()'");
        // wrong with fmt, OK with work-around:
        for val in vec![0.04_f64, 0.05, 0.06, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.94, 0.95, 0.96] {
            let nval = -val;
            println!("{val:<5}: {val:.1}  <> {},   {nval:<5}:  {nval:.1}  <> {}",
                     f64_sround(val, 1, policy),
                     f64_sround(nval, 1, policy));
        }
        // some values wrong with work-around too (0.145):
        for val in vec![0.104, 0.105, 0.106, 0.115, 0.125, 0.135, 0.145, 0.155, 0.165, 0.175, 0.185, 0.194, 0.195, 0.196, 0.994, 0.995, 0.996] {
            let nval = -val;
            println!("{val:<5}: {val:.2} <> {},  {nval:<5}: {nval:.2} <> {}",
                     f64_sround(val, 2, policy),
                     f64_sround(nval, 2, policy));
        }

        for val in vec![1.4, 1.5, 1.6, 2.4, 2.5, 2.6, 9.4, 9.5, 9.6] {
            let nval = -val;
            println!("{val:<5}: {val:>2.0} <> {:>2},  {nval:<5}: {nval:>3.0} <> {:>3}",
                     f64_sround(val, 0, policy),
                     f64_sround(nval, 0, policy));
        }

    }
}

#[test]
fn round_test_iter() {
    let exp_list = &[("0.4", 0_usize), ("0.5", 0), ("0.04", 1), ("0.05", 1), ("0.004", 2), ("0.005", 2), ("0.014", 2), ("0.015", 2),
        ("0.024", 2), ("0.025", 2), ("0.034", 2), ("0.035", 2), ("0.044", 2), ("0.045", 2), ("0.054", 2), ("0.055", 2),
        ("0.064", 2), ("0.065", 2), ("0.074", 2), ("0.075", 2), ("0.084", 2), ("0.085", 2), ("0.094", 2), ("0.095", 2),
        ("0.14", 1), ("0.15", 1), ("0.104", 2), ("0.105", 2), ("0.114", 2), ("0.115", 2), ("0.124", 2), ("0.125", 2),
        ("0.134", 2), ("0.135", 2), ("0.144", 2), ("0.145", 2), ("0.154", 2), ("0.155", 2), ("0.164", 2), ("0.165", 2),
        ("0.174", 2), ("0.175", 2), ("0.184", 2), ("0.185", 2), ("0.194", 2), ("0.195", 2), ("0.24", 1), ("0.25", 1),
        ("0.204", 2), ("0.205", 2), ("0.214", 2), ("0.215", 2), ("0.224", 2), ("0.225", 2), ("0.234", 2), ("0.235", 2),
        ("0.244", 2), ("0.245", 2), ("0.254", 2), ("0.255", 2), ("0.264", 2), ("0.265", 2), ("0.274", 2), ("0.275", 2),
        ("0.284", 2), ("0.285", 2), ("0.294", 2), ("0.295", 2), ("0.34", 1), ("0.35", 1), ("0.304", 2), ("0.305", 2),
        ("0.314", 2), ("0.315", 2), ("0.324", 2), ("0.325", 2), ("0.334", 2), ("0.335", 2), ("0.344", 2), ("0.345", 2),
        ("0.354", 2), ("0.355", 2), ("0.364", 2), ("0.365", 2), ("0.374", 2), ("0.375", 2), ("0.384", 2), ("0.385", 2),
        ("0.394", 2), ("0.395", 2), ("0.44", 1), ("0.45", 1), ("0.404", 2), ("0.405", 2), ("0.414", 2), ("0.415", 2),
        ("0.424", 2), ("0.425", 2), ("0.434", 2), ("0.435", 2), ("0.444", 2), ("0.445", 2), ("0.454", 2), ("0.455", 2),
        ("0.464", 2), ("0.465", 2), ("0.474", 2), ("0.475", 2), ("0.484", 2), ("0.485", 2), ("0.494", 2), ("0.495", 2),
        ("0.54", 1), ("0.55", 1), ("0.504", 2), ("0.505", 2), ("0.514", 2), ("0.515", 2), ("0.524", 2), ("0.525", 2),
        ("0.534", 2), ("0.535", 2), ("0.544", 2), ("0.545", 2), ("0.554", 2), ("0.555", 2), ("0.564", 2), ("0.565", 2),
        ("0.574", 2), ("0.575", 2), ("0.584", 2), ("0.585", 2), ("0.594", 2), ("0.595", 2), ("0.64", 1), ("0.65", 1),
        ("0.604", 2), ("0.605", 2), ("0.614", 2), ("0.615", 2), ("0.624", 2), ("0.625", 2), ("0.634", 2), ("0.635", 2),
        ("0.644", 2), ("0.645", 2), ("0.654", 2), ("0.655", 2), ("0.664", 2), ("0.665", 2), ("0.674", 2), ("0.675", 2),
        ("0.684", 2), ("0.685", 2), ("0.694", 2), ("0.695", 2), ("0.74", 1), ("0.75", 1), ("0.704", 2), ("0.705", 2),
        ("0.714", 2), ("0.715", 2), ("0.724", 2), ("0.725", 2), ("0.734", 2), ("0.735", 2), ("0.744", 2), ("0.745", 2),
        ("0.754", 2), ("0.755", 2), ("0.764", 2), ("0.765", 2), ("0.774", 2), ("0.775", 2), ("0.784", 2), ("0.785", 2),
        ("0.794", 2), ("0.795", 2), ("0.84", 1), ("0.85", 1), ("0.804", 2), ("0.805", 2), ("0.814", 2), ("0.815", 2),
        ("0.824", 2), ("0.825", 2), ("0.834", 2), ("0.835", 2), ("0.844", 2), ("0.845", 2), ("0.854", 2), ("0.855", 2),
        ("0.864", 2), ("0.865", 2), ("0.874", 2), ("0.875", 2), ("0.884", 2), ("0.885", 2), ("0.894", 2), ("0.895", 2),
        ("0.94", 1), ("0.95", 1), ("0.904", 2), ("0.905", 2), ("0.914", 2), ("0.915", 2), ("0.924", 2), ("0.925", 2),
        ("0.934", 2), ("0.935", 2), ("0.944", 2), ("0.945", 2), ("0.954", 2), ("0.955", 2), ("0.964", 2), ("0.965", 2),
        ("0.974", 2), ("0.975", 2), ("0.984", 2), ("0.985", 2), ("0.994", 2), ("0.995", 2)];
    let exp_list = exp_list.iter().filter(|(a, _)| INIT_DIGIT == b'4' || a.ends_with('5')).collect::<Vec<_>>();
    let iter = RoundTestIter::new(3, false);
    for (idx, ((s, pr), (exp_s, exp_pr))) in iter.zip(exp_list).enumerate() {
        let reference = format!("value index {idx}: ({s}, {pr}) instead of ({exp_s}, {exp_pr})");
        assert_eq!(s, *exp_s, "{}", reference);
        assert_eq!(pr, *exp_pr, "{}", reference);
    }
    println!();
}
